{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "src/interfaces/IMultipass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\n\nimport {LibMultipass} from \"../libraries/LibMultipass.sol\";\n\n/**\n * @title IMultipass\n * @notice Interface for the Multipass contract. Multipass contract acts as cross-domain registry, allowing owner to specify registrars and domains that can be used to register names.\n * It also allows for referral program, where referrers can earn rewards for referring new registrations.\n * @custom:security-contact sirt@peeramid.xyz\n */\ninterface IMultipass {\n    enum InvalidQueryReasons {\n        EMPTY_ID,\n        EMPTY_DOMAIN,\n        EMPTY_ADDRESS\n    }\n\n    error invalidQuery(InvalidQueryReasons reason);\n    error nameExists(bytes32 name);\n    error recordExists(LibMultipass.Record newRecord);\n    error isActive(bytes32 name, bool isActive);\n    error signatureExpired(uint256 signatureDeadline);\n    error invalidSignature();\n    error mathOverflow(uint256 a, uint256 b);\n    error invalidDomain(bytes32 domainName);\n    error referralRewardsTooHigh(uint256 referrerReward, uint256 referralDiscount, uint256 fee);\n    error invalidRegistrar(address registrar);\n    error paymentTooLow(uint256 fee, uint256 value);\n    error paymendFailed();\n    error referredSelf();\n    error domainNotActive(bytes32 domainName);\n    error userNotFound(LibMultipass.NameQuery query);\n    error invalidnameChange(bytes32 domainName, bytes32 newName);\n    error invalidNonce(uint256 nonce);\n    error invalidNonceIncrement(uint256 old, uint256 newer);\n\n    /**\n     * @dev Retrieves the resolved record for a given name query.\n     * @param query The name query to resolve.\n     * @return A boolean indicating whether the record was found, and the resolved record.\n     */\n    function resolveRecord(\n        LibMultipass.NameQuery memory query\n    ) external view returns (bool, LibMultipass.Record memory);\n\n    /**\n     * @dev Initializes new LibMultipass.Domain and configures it's parameters\n     *\n     * Requirements:\n     *  registrar is not zero\n     *  domainName is not empty\n     *  domainIndex is either zero(auto assign) or can be one of preoccupied LibMultipass.Domain names\n     *  domainName does not exist yet\n     *  onlyOwner\n     *  referrerReward+referralDiscount cannot be larger than fee\n     *  @param registrar address of registrar\n     *  @param fee fee in base currency of network\n     *  @param domainName name of LibMultipass.Domain\n     *  @param referrerReward referral fee share in base currency of network\n     *  @param referralDiscount referral discount in base currency of network\n     *\n     *  Emits an {InitializedDomain} event.\n     */\n    function initializeDomain(\n        address registrar,\n        uint256 fee,\n        uint256 renewalFee,\n        bytes32 domainName,\n        uint256 referrerReward,\n        uint256 referralDiscount\n    ) external;\n\n    /**\n     * @dev Activates LibMultipass.Domain name\n     *\n     * Requirements:\n     *  msg.sender is Owner\n     *\n     *\n     *  Emits an {DomainActivated} event.\n     */\n    function activateDomain(bytes32 domainName) external;\n\n    /**\n     * @dev Deactivates LibMultipass.Domain name\n     *\n     * Deactivated LibMultipass.Domain cannot mutate names and will return zeros\n     *\n     * Requirements:\n     *  msg.sender is Owner OR registrar\n     *\n     *\n     *  Emits an {DomainDeactivated} event.\n     */\n    function deactivateDomain(bytes32 domainName) external;\n\n    /**\n     * @dev Changes registrar address\n     *\n     * Requirements:\n     *  msg.sender is Owner\n     *\n     *  Emits an {DomainFeeChanged} event.\n     */\n    function changeFee(bytes32 domainName, uint256 fee) external;\n\n    /**\n     * @dev Changes registrar address\n     *\n     * Requirements:\n     *  msg.sender is Owner\n     *\n     *  Emits an {RegistrarChangeRequested} event.\n     */\n    function changeRegistrar(bytes32 domainName, address newRegistrar) external;\n\n    /**\n     * @dev deletes name\n     *\n     * Requirements:\n     *  msg.sender is Owner\n     *\n     *  Emits an {DomainTTLChangeRequested} event.\n     */\n    function deleteName(LibMultipass.NameQuery memory query) external;\n\n    /**\n     * @dev executes all pending changes to LibMultipass.Domain that fulfill TTL\n     *\n     * Requirements:\n     *  domainName must be set\n     *  referrerFeeShare+referralDiscount cannot be larger than 2^32\n     *\n     *\n     *  Emits an {ReferralProgramChangeRequested} event.\n     */\n    function changeReferralProgram(uint256 referrerFeeShare, uint256 referralDiscount, bytes32 domainName) external;\n\n    /**\n     * @dev changes renewal fee for domain\n     *\n     * Requirements:\n     *  domainName must be set\n     *  fee must be set\n     *\n     *\n     *  Emits an {RenewalFeeChangeRequested} event.\n     */\n    function changeRenewalFee(uint256 fee, bytes32 domainName) external;\n\n    /**\n     * @dev registers new name under LibMultipass.Domain\n     *\n     * Requirements:\n     *  all arguments must be set\n     *  domainName must be active\n     * resolveRecord for given arguments should return no LibMultipass.Record\n     *\n     *\n     *  Emits an {registered} event.\n     */\n    function register(\n        LibMultipass.Record memory newRecord,\n        bytes memory registrarSignature,\n        LibMultipass.NameQuery memory referrer,\n        bytes memory referralCode\n    ) external payable;\n\n    /**\n     * @dev returns LibMultipass.Domain state variables\n     * @param domainName name of the LibMultipass.Domain\n     * @return (name,\n      fee,\n       referrerReward,\n       referralDiscount,\n       isActive,\n       registrar,\n       ttl,\n        registerSize)\n     */\n    function getDomainState(bytes32 domainName) external view returns (LibMultipass.Domain memory);\n\n    /**\n     * @dev returns contract state variables\n\n     * @return (s_numDomains)\n     */\n    function getContractState() external view returns (uint256);\n    /**\n     * @dev returns price for registering name\n     *\n     */\n    event fundsWithdawn(uint256 indexed amount, address indexed account);\n\n    /**\n     * @dev Initializes a new domain with the specified parameters.\n     * @param registrar The address of the registrar for the domain.\n     * @param fee The fee required for registration in the domain.\n     * @param domainName The name of the domain.\n     * @param referrerReward The reward for referring new registrations to the domain.\n     * @param referralDiscount The discount for referrals in the domain.\n     */\n    event InitializedDomain(\n        address indexed registrar,\n        uint256 indexed fee,\n        bytes32 indexed domainName,\n        uint256 renewalFee,\n        uint256 referrerReward,\n        uint256 referralDiscount\n    );\n\n    /**\n     * @dev Emitted when a domain is activated.\n     * @param domainName The name of the activated domain.\n     */\n    event DomainActivated(bytes32 indexed domainName);\n\n    /**\n     * @dev Emitted when a domain is deactivated.\n     * @param domainName The name of the deactivated domain.\n     */\n    event DomainDeactivated(bytes32 indexed domainName);\n\n    /**\n     * @dev Emitted when the fee for a domain is changed.\n     * @param domainName The name of the domain.\n     * @param newFee The new fee for the domain.\n     */\n    event DomainFeeChanged(bytes32 indexed domainName, uint256 indexed newFee);\n\n    /**\n     * @dev Emitted when a registrar change is requested for a domain.\n     * @param domainName The name of the domain.\n     * @param registrar The address of the new registrar.\n     */\n    event RegistrarChanged(bytes32 indexed domainName, address indexed registrar);\n\n    /**\n     * @dev Emitted when a name is deleted.\n     * @param domainName The domain name.\n     * @param wallet The address of the wallet.\n     * @param id The ID of the name.\n     * @param name The name.\n     */\n    event nameDeleted(bytes32 indexed domainName, address indexed wallet, bytes32 indexed id, bytes32 name);\n\n    /**\n     * @dev Emitted when the referral program for a domain is changed.\n     * @param domainName The domain name.\n     * @param reward The referral reward amount.\n     * @param discount The referral discount amount.\n     */\n    event ReferralProgramChanged(bytes32 indexed domainName, uint256 reward, uint256 discount);\n\n    /**\n     * @dev Emitted when a domain is registered.\n     * @param domainName The domain name.\n     * @param NewRecord The new record.\n     */\n    event Registered(bytes32 indexed domainName, LibMultipass.Record NewRecord);\n\n    /**\n     * @dev Emitted when a user is referred.\n     * @param refferrer The record of the referrer.\n     * @param newRecord The new record.\n     * @param domainName The domain name.\n     */\n    event Referred(LibMultipass.Record refferrer, LibMultipass.Record newRecord, bytes32 indexed domainName);\n\n    /**\n     * @dev Emitted when a user record is renewed.\n     * @param wallet The address of the wallet.\n     * @param domainName The domain name.\n     * @param id The ID of the record.\n     * @param newRecord The new record.\n     */\n    event Renewed(\n        address indexed wallet,\n        bytes32 indexed domainName,\n        bytes32 indexed id,\n        LibMultipass.Record newRecord\n    );\n\n    /**\n     * @dev Emitted when a domain renewal fee is changed.\n     * @param domainName The domain name.\n     * @param newFee The new renewal fee.\n     */\n    event RenewalFeeChanged(bytes32 indexed domainName, uint256 indexed newFee);\n\n    /**\n     * @dev Retrieves the domain state by its ID.\n     * @param id The ID of the domain.\n     * @return The domain state as a `LibMultipass.Domain` struct.\n     */\n    function getDomainStateById(uint256 id) external view returns (LibMultipass.Domain memory);\n\n    /**\n     * @notice renews record for given query\n     * @param query name query\n     * @param record new record\n     * @param registrarSignature registrar signature\n     */\n    function renewRecord(\n        LibMultipass.NameQuery memory query,\n        LibMultipass.Record memory record,\n        bytes memory registrarSignature\n    ) external payable;\n}\n"
    },
    "src/libraries/LibMultipass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title LibMultipass\n * @notice Library for handling multipass functionality.\n *\n * This library provides a set of functions to manage and utilize multipass features.\n * It is designed to be used as a part of the multipass system within the project.\n * @custom:security-contact sirt@peeramid.xyz\n */\nlibrary LibMultipass {\n    /**\n     * @dev resolves user from any given argument\n     * Requirements:\n     *  domainName must be given and must be initialized\n     *  id OR username OR address must be given\n     * This method first tries to resolve by address, then by user id and finally by username\n     * @param domainName domain name\n     * @param wallet adress of user\n     * @param id user id\n     * @param username username\n     * @param targetDomain if this is set to valid domain name, then after sucessfull resolving account at domainName,\n     *                       this method will rerun with resolving user properties in targetDomain\n     */\n    struct NameQuery {\n        bytes32 domainName;\n        address wallet;\n        bytes32 name;\n        bytes32 id;\n        bytes32 targetDomain;\n    }\n\n    /**\n     * @dev The domain name of the registrar.\n     * @param registrar is the address private key of which is owned by signing server (e.g. Discord bot server)\n     * @param name is unique string that is used to find this domain within domains.\n\n     * @param fee amount of payment requried to register name in the domain\n     * @param ttl time to live for changes in the domain properties\n     * @param isActive when is false domain name will not respond to any changes and will not return any address\n    **/\n    struct Domain {\n        bytes32 name; //32bytes\n        uint256 fee; //32bytes\n        uint256 referrerReward; //32bytes\n        uint256 referralDiscount; //32bytes\n        bool isActive; //1byte\n        address registrar; //20 bytes\n        uint24 ttl; //3 bytes (not being used for now)\n        uint256 registerSize; //32bytes\n        uint256 renewalFee; //32bytes\n    }\n\n    /**\n     * @dev The record in the registry.\n     * @param wallet is the address of the user\n     * @param name is the name of the user\n     * @param id is the unique identificator of the user\n     * @param nonce is the number of changes in the user record\n     * @param domainName is the domain name of the registrar\n     **/\n    struct Record {\n        address wallet;\n        bytes32 name;\n        bytes32 id;\n        uint96 nonce;\n        bytes32 domainName;\n        uint256 validUntil;\n    }\n\n    bytes32 private constant MULTIPASS_STORAGE_POSITION = bytes32(uint256(keccak256(\"multipass.storage.struct\")) - 1);\n\n    /**\n     * @dev The domain name of the registrar.\n     * @param properties - domain configuration\n     * @param idToAddress is mapping from unique identificator to an address\n     * @param registerSize is number of registered users for this domain\n     * @param nonce is incremented each time Record changes in addressToId map\n     * @param nameToId is mapping from names to unique identificator. While each name required to be unique,\n                        names might change on the domain, so we keep records to user identificators as immutable property of user\n     * @param addressToId is mapping from an address to unique identificator\n     * @param idToName is mapping from identificator to a name\n    **/\n    struct DomainStorage {\n        Domain properties; //128 bytes\n        mapping(bytes32 => address) idToAddress; //N*20bytes\n        mapping(bytes32 => uint96) nonce; //N*12bytes\n        mapping(address => bytes32) addressToId; //N*32 bytes\n        mapping(bytes32 => bytes32) nameToId; //N*32 bytes\n        mapping(bytes32 => bytes32) idToName; //N*32 bytes\n        mapping(address => uint256) validUntil; //N*32 bytes\n    }\n\n    /**\n     * @dev The storage structure for the Multipass contract.\n     * @param domains is mapping from domain index to domain properties\n     * @param domainNameToIndex is mapping from domain name to domain index\n     */\n    struct MultipassStorageStruct {\n        mapping(uint256 => DomainStorage) domains;\n        mapping(bytes32 => uint256) domainNameToIndex; //helper to get domain index by name\n        uint256 numDomains;\n    }\n\n    /**\n     * @dev Returns the storage struct for the Multipass contract.\n     */\n    function MultipassStorage() private pure returns (MultipassStorageStruct storage es) {\n        bytes32 position = MULTIPASS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n\n    bytes32 internal constant _TYPEHASH =\n        keccak256(\"registerName(bytes32 name,bytes32 id,bytes32 domainName,uint256 validUntil,uint96 nonce)\");\n    bytes32 internal constant _TYPEHASH_REFERRAL = keccak256(\"proofOfReferrer(address referrerAddress)\");\n\n    function _checkNotEmpty(bytes32 value) internal pure returns (bool) {\n        if (value == \"\") {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Resolves the index of a domain name in the Multipass storage.\n     * @param domainName The domain name to resolve the index for.\n     * @return The index of the domain name in the storage.\n     */\n    function resolveDomainIndex(bytes32 domainName) internal view returns (uint256) {\n        MultipassStorageStruct storage s = MultipassStorage();\n        return s.domainNameToIndex[domainName];\n    }\n\n    function _getDomainStorage(bytes32 domainName) internal view returns (DomainStorage storage) {\n        MultipassStorageStruct storage s = MultipassStorage();\n\n        return s.domains[resolveDomainIndex(domainName)];\n    }\n\n    function _initializeDomain(\n        address registrar,\n        uint256 fee,\n        uint256 renewalFee,\n        bytes32 domainName,\n        uint256 referrerReward,\n        uint256 referralDiscount\n    ) internal {\n        LibMultipass.MultipassStorageStruct storage ms = MultipassStorage();\n\n        uint256 domainIndex = ms.numDomains + 1;\n        LibMultipass.DomainStorage storage _domain = ms.domains[domainIndex];\n        _domain.properties.registrar = registrar;\n        _domain.properties.fee = fee;\n        _domain.properties.name = domainName;\n        _domain.properties.referrerReward = referrerReward;\n        _domain.properties.referralDiscount = referralDiscount;\n        _domain.properties.renewalFee = renewalFee;\n        ms.numDomains++;\n        ms.domainNameToIndex[domainName] = domainIndex;\n    }\n\n    function _resolveRecord(NameQuery memory query) private view returns (bool, Record memory) {\n        if ((query.wallet == address(0)) && (query.id == bytes32(0)) && (query.name == bytes32(0))) {\n            Record memory rv;\n            return (false, rv);\n        }\n\n        MultipassStorageStruct storage s = MultipassStorage();\n        DomainStorage storage _domain = s.domains[s.domainNameToIndex[query.domainName]];\n        DomainStorage storage _targetDomain = s.domains[\n            s.domainNameToIndex[query.targetDomain == bytes32(0) ? query.domainName : query.targetDomain]\n        ];\n        address _wallet;\n        {\n            // resolve wallet\n            if (query.wallet != address(0)) {\n                _wallet = query.wallet;\n            } else if (query.id != bytes32(0)) {\n                _wallet = _domain.idToAddress[query.id];\n            } else if (query.name != bytes32(0)) {\n                bytes32 _id = _domain.nameToId[query.name];\n                _wallet = _domain.idToAddress[_id];\n            }\n        }\n\n        //from wallet find and return record\n        return _resolveFromAddress(_wallet, _targetDomain);\n    }\n\n    /**\n     * @dev Resolves the record of a user.\n     * @param query The query to resolve the record for.\n     * @return The record of the user.\n     * @dev resolves Record of name query in to status and identity\n     */\n    function resolveRecord(NameQuery memory query) internal view returns (bool, Record memory) {\n        return _resolveRecord(query);\n    }\n\n    /** @dev this function bears no security checks, it will ignore nonce in arg and will increment\n     *   nonce value stored in domain instread\n     */\n    function _setRecord(DomainStorage storage domain, Record memory record) internal {\n        domain.addressToId[record.wallet] = record.id;\n        domain.idToAddress[record.id] = record.wallet;\n        domain.idToName[record.id] = record.name;\n        domain.nameToId[record.name] = record.id;\n        domain.nonce[record.id] += 1;\n        domain.validUntil[record.wallet] = record.validUntil;\n    }\n\n    function _resolveFromAddress(\n        address _address,\n        DomainStorage storage _domain\n    ) private view returns (bool, Record memory) {\n        Record memory resolved;\n\n        resolved.id = _domain.addressToId[_address];\n        resolved.name = _domain.idToName[resolved.id];\n        resolved.nonce = _domain.nonce[resolved.id];\n        resolved.wallet = _address;\n        resolved.domainName = _domain.properties.name;\n        resolved.validUntil = _domain.validUntil[_address];\n\n        if (resolved.id == bytes32(0)) {\n            return (false, resolved);\n        }\n        return (true, resolved);\n    }\n    /**\n     * @dev Resolves the record of a user.\n     * @param _record The record to resolve the query for.\n     * @return query result.\n     */\n    function queryFromRecord(Record memory _record) internal pure returns (NameQuery memory) {\n        NameQuery memory _query;\n        _query.id = _record.id;\n        _query.domainName = _record.domainName;\n        _query.name = _record.name;\n        _query.wallet = _record.wallet;\n        return _query;\n    }\n\n    function _registerNew(Record memory newRecord, DomainStorage storage domain) internal {\n        _setRecord(domain, newRecord);\n        domain.properties.registerSize += 1;\n    }\n\n    function _getContractState() internal view returns (uint256) {\n        LibMultipass.MultipassStorageStruct storage ms = MultipassStorage();\n        return ms.numDomains;\n    }\n\n    function _getDomainStorageById(uint256 id) internal view returns (DomainStorage storage) {\n        MultipassStorageStruct storage s = MultipassStorage();\n\n        return s.domains[id];\n    }\n\n    using LibMultipass for NameQuery;\n}\n"
    },
    "src/Multipass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.28;\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"./interfaces/IMultipass.sol\";\nimport \"./libraries/LibMultipass.sol\";\n/**\n * @title Multipass\n * @dev This contract implements various functions related to the management of domain names and registration records.\n * @custom:security-contact sirt@peeramid.xyz\n */\ncontract Multipass is ERC165Upgradeable, EIP712Upgradeable, IMultipass, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n    using ECDSA for bytes32;\n    using LibMultipass for bytes32;\n\n    // using LibMultipass for LibMultipass.Record;\n    using LibMultipass for LibMultipass.Record;\n    using LibMultipass for bytes;\n\n    constructor() {\n        _disableInitializers();\n    }\n    /**\n     * @notice Initializes the contract with a name, version, and owner address.\n     * This function can only be called once due to the `initializer` modifier.\n     * @param name The name to initialize the contract with.\n     * @param version The version to initialize the contract with.\n     * @param owner The address of the owner of the contract.\n     */\n    function initialize(string memory name, string memory version, address owner) external initializer {\n        __Ownable_init(owner);\n        __EIP712_init(name, version);\n    }\n\n    function _isValidSignature(\n        bytes memory message,\n        bytes memory signature,\n        address account\n    ) internal view returns (bool) {\n        bytes32 typedHash = _hashTypedDataV4(keccak256(message));\n        return SignatureChecker.isValidSignatureNow(account, typedHash, signature);\n    }\n\n    function _validateRecord(LibMultipass.Record memory newRecord, bytes memory registrarSignature) private view {\n        LibMultipass.NameQuery memory query = LibMultipass.queryFromRecord(newRecord);\n        //Check name query is legit\n        require(LibMultipass._checkNotEmpty(query.id), invalidQuery(InvalidQueryReasons.EMPTY_ID));\n        require(LibMultipass._checkNotEmpty(query.domainName), invalidQuery(InvalidQueryReasons.EMPTY_DOMAIN));\n        require(query.wallet != address(0), invalidQuery(InvalidQueryReasons.EMPTY_ADDRESS));\n        //Check LibMultipass.Domain is legit\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(query.domainName);\n        require(_domain.properties.isActive, isActive(_domain.properties.name, false));\n\n        //check signatures and time\n        require(newRecord.validUntil > block.timestamp, signatureExpired(newRecord.validUntil));\n\n        {\n            bytes memory registrarMessage = abi.encode(\n                LibMultipass._TYPEHASH,\n                newRecord.name,\n                newRecord.id,\n                newRecord.domainName,\n                newRecord.validUntil,\n                newRecord.nonce\n            );\n\n            require(\n                _isValidSignature(registrarMessage, registrarSignature, _domain.properties.registrar),\n                invalidSignature()\n            );\n        }\n    }\n\n    /// @inheritdoc IMultipass\n    function initializeDomain(\n        address registrar,\n        uint256 fee,\n        uint256 renewalFee,\n        bytes32 domainName,\n        uint256 referrerReward,\n        uint256 referralDiscount\n    ) public override onlyOwner {\n        require(registrar != address(0), invalidRegistrar(registrar));\n        require(LibMultipass._checkNotEmpty(domainName), invalidQuery(InvalidQueryReasons.EMPTY_DOMAIN));\n        require(LibMultipass.resolveDomainIndex(domainName) == 0, nameExists(domainName));\n        (bool status, uint256 result) = Math.tryAdd(referrerReward, referralDiscount);\n        require(status, mathOverflow(referrerReward, referralDiscount));\n        require(result <= fee, referralRewardsTooHigh(referrerReward, referralDiscount, fee));\n\n        LibMultipass._initializeDomain(registrar, fee, renewalFee, domainName, referrerReward, referralDiscount);\n        emit InitializedDomain(registrar, fee, domainName, renewalFee, referrerReward, referralDiscount);\n    }\n\n    function _enforseDomainNameIsValid(bytes32 domainName) private view {\n        require(domainName._checkNotEmpty(), invalidDomain(domainName));\n        require(domainName.resolveDomainIndex() != 0, invalidDomain(domainName));\n    }\n\n    /// @inheritdoc IMultipass\n    function activateDomain(bytes32 domainName) external override onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        _domain.properties.isActive = true;\n        emit DomainActivated(domainName);\n    }\n\n    /// @inheritdoc IMultipass\n    function deactivateDomain(bytes32 domainName) public override onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        _domain.properties.isActive = false;\n        emit DomainDeactivated(domainName);\n    }\n\n    /// @inheritdoc IMultipass\n    function changeFee(bytes32 domainName, uint256 fee) public override onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        uint256 _referrerReward = _domain.properties.referrerReward;\n        uint256 _referralDiscount = _domain.properties.referralDiscount;\n        require(\n            _referralDiscount + _referrerReward <= fee,\n            referralRewardsTooHigh(_referrerReward, _referralDiscount, fee)\n        );\n        _domain.properties.fee = fee;\n        emit DomainFeeChanged(domainName, fee);\n    }\n\n    /// @inheritdoc IMultipass\n    function changeRegistrar(bytes32 domainName, address newRegistrar) external override onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        require(newRegistrar != address(0), invalidRegistrar(newRegistrar));\n        _domain.properties.registrar = newRegistrar;\n        emit RegistrarChanged(domainName, newRegistrar);\n    }\n\n    /// @inheritdoc IMultipass\n    function deleteName(\n        LibMultipass.NameQuery memory query // bytes32 domainName, // address wallet, // bytes32 username, // bytes32 id\n    ) external override onlyOwner {\n        _enforseDomainNameIsValid(query.domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(query.domainName);\n        query.targetDomain = \"\";\n        (bool status, LibMultipass.Record memory r) = resolveRecord(query);\n        require(status, userNotFound(query));\n        _domain.addressToId[r.wallet] = bytes32(0);\n        _domain.idToAddress[r.id] = address(0);\n        _domain.idToName[r.id] = bytes32(0);\n        _domain.nameToId[r.name] = bytes32(0);\n        _domain.validUntil[r.wallet] = 0;\n        _domain.nonce[r.id] += 1;\n        _domain.properties.registerSize--;\n\n        emit nameDeleted(_domain.properties.name, r.wallet, r.id, r.name);\n    }\n\n    /// @inheritdoc IMultipass\n    function changeReferralProgram(\n        uint256 referrerReward,\n        uint256 referralDiscount,\n        bytes32 domainName\n    ) external override onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        (bool status, uint256 result) = Math.tryAdd(referrerReward, referralDiscount);\n        require(status, mathOverflow(referrerReward, referralDiscount));\n        require(\n            result <= _domain.properties.fee,\n            referralRewardsTooHigh(referrerReward, referralDiscount, _domain.properties.fee)\n        );\n        _domain.properties.referrerReward = referrerReward;\n        _domain.properties.referralDiscount = referralDiscount;\n        emit ReferralProgramChanged(domainName, referrerReward, referralDiscount);\n    }\n\n    /// @inheritdoc IMultipass\n    function resolveRecord(\n        LibMultipass.NameQuery memory query\n    ) public view override returns (bool, LibMultipass.Record memory) {\n        return LibMultipass.resolveRecord(query);\n    }\n\n    /// @inheritdoc IMultipass\n    function register(\n        LibMultipass.Record memory newRecord,\n        bytes memory registrarSignature,\n        LibMultipass.NameQuery memory referrer,\n        bytes memory referralCode\n    ) external payable override nonReentrant {\n        _enforseDomainNameIsValid(newRecord.domainName);\n        //Check query does not resolves (name already exists)\n\n        {\n            LibMultipass.NameQuery memory query = LibMultipass.queryFromRecord(newRecord);\n            {\n                (bool success, LibMultipass.Record memory r) = LibMultipass.resolveRecord(query);\n                require(!success, recordExists(r));\n            }\n            {\n                query.wallet = address(0);\n                (bool success, LibMultipass.Record memory r) = LibMultipass.resolveRecord(query);\n                require(!success, recordExists(r));\n            }\n            {\n                query.id = bytes32(0);\n                (bool success, LibMultipass.Record memory r) = LibMultipass.resolveRecord(query);\n                require(!success, recordExists(r));\n            }\n        }\n        _validateRecord(newRecord, registrarSignature);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(newRecord.domainName);\n        (bool hasValidReferrer, LibMultipass.Record memory referrerRecord) = LibMultipass.resolveRecord(referrer);\n\n        uint256 referrersShare = hasValidReferrer ? _domain.properties.referrerReward : 0;\n        uint256 valueToPay = _domain.properties.fee - (hasValidReferrer ? _domain.properties.referralDiscount : 0);\n        require(msg.value >= valueToPay, paymentTooLow(valueToPay, msg.value));\n        uint256 ownerShare = msg.value - referrersShare;\n        {\n            (bool success, ) = payable(owner()).call{value: ownerShare}(\"\");\n            require(success, paymendFailed());\n        }\n\n        if (hasValidReferrer) {\n            require(referrerRecord.wallet != newRecord.wallet, referredSelf());\n            {\n                bytes memory refferalMessage = abi.encode(LibMultipass._TYPEHASH_REFERRAL, referrerRecord.wallet);\n                require(_isValidSignature(refferalMessage, referralCode, referrerRecord.wallet), invalidSignature());\n                (bool success, ) = payable(referrerRecord.wallet).call{value: referrersShare}(\"\");\n                require(success, paymendFailed());\n            }\n            emit Referred(referrerRecord, newRecord, newRecord.domainName);\n        }\n\n        LibMultipass._registerNew(newRecord, _domain);\n        emit Registered(_domain.properties.name, newRecord);\n    }\n\n    /// @inheritdoc IMultipass\n    function renewRecord(\n        LibMultipass.NameQuery memory query,\n        LibMultipass.Record memory record,\n        bytes memory registrarSignature\n    ) external payable override nonReentrant {\n        _enforseDomainNameIsValid(record.domainName);\n        (bool userExists, LibMultipass.Record memory userRecord) = LibMultipass.resolveRecord(query);\n        require(userRecord.nonce < record.nonce, invalidNonceIncrement(userRecord.nonce, record.nonce));\n        require(userRecord.domainName == record.domainName, invalidDomain(userRecord.domainName));\n        _validateRecord(record, registrarSignature);\n        require(userExists, userNotFound(query));\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(record.domainName);\n        require(_domain.properties.isActive, domainNotActive(record.domainName));\n        require(record.validUntil >= block.timestamp, signatureExpired(record.validUntil));\n        emit Renewed(record.wallet, record.domainName, record.id, record);\n        if (_domain.properties.renewalFee > 0) {\n            require(\n                msg.value >= _domain.properties.renewalFee,\n                paymentTooLow(_domain.properties.renewalFee, msg.value)\n            );\n            (bool success, ) = payable(owner()).call{value: _domain.properties.renewalFee}(\"\");\n            require(success, paymendFailed());\n        }\n    }\n\n    /// @inheritdoc IMultipass\n    function getDomainState(bytes32 domainName) external view override returns (LibMultipass.Domain memory) {\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        return _domain.properties;\n    }\n\n    /// @inheritdoc IMultipass\n    function getDomainStateById(uint256 id) external view returns (LibMultipass.Domain memory) {\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorageById(id);\n        return _domain.properties;\n    }\n\n    /// @inheritdoc IMultipass\n    function getContractState() external view override returns (uint256) {\n        return LibMultipass._getContractState();\n    }\n\n    /**\n     * @dev Checks if the contract supports a given interface.\n     * @param interfaceId The interface identifier, as specified in ERC-165.\n     * @return bool True if the contract supports the given interface, false otherwise.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IMultipass).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IMultipass\n    function changeRenewalFee(uint256 fee, bytes32 domainName) external onlyOwner {\n        _enforseDomainNameIsValid(domainName);\n        LibMultipass.DomainStorage storage _domain = LibMultipass._getDomainStorage(domainName);\n        _domain.properties.renewalFee = fee;\n        emit RenewalFeeChanged(domainName, fee);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}